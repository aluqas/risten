//! # risten - Static-First Event Processing Framework
//!
//! `risten` is an event processing framework designed with a **static-first** philosophy.
//! Compile-time optimizations are the default path; dynamic dispatch is available as an
//! explicit escape hatch for runtime flexibility.
//!
//! ## Quick Start (Static Path - Recommended)
//!
//! ```rust,ignore
//! use risten::{static_hooks, StaticDispatcher, HCons, HNil, Hook, HookResult};
//!
//! // Define your hooks
//! struct MyHook;
//! impl Hook<MyEvent> for MyHook { ... }
//!
//! // Build a static chain (zero-cost at runtime)
//! type MyChain = HCons<MyHook, HNil>;
//! static DISPATCHER: StaticDispatcher<MyChain> = ...;
//! ```

#![deny(clippy::pub_use, clippy::wildcard_imports)]
#![warn(missing_docs)]

// 1. Internal Implementation Modules (Private / Restricted)
// These modules are implementation details and suppressed from public docs.
// ----------------------------------------------------------------------------

pub(crate) mod core;
pub(crate) mod flow;
pub(crate) mod orchestrator;
pub(crate) mod std;

// 2. Feature-gated or specific exposed modules (Restricted)
// ----------------------------------------------------------------------------
// #[cfg(feature = "tower")]
// pub mod tower_compat; // [TODO] Move to std/hooks/tower.rs in future step if not already

// The following legacy modules are either moved or need to be handled.
// pub mod delivery; // [TODO] Check if this is still needed as top-level or moved to orchestrator
// pub mod observability; // [TODO] Check if this is still needed

// 3. Public Facade (Re-exports)
// The intentional public API surface.
// ----------------------------------------------------------------------------

// ============================================================================
// Core Primitive Types (from `core`)
// ============================================================================
pub use crate::core::{
    context::{ExtractError, FromEvent},
    error::{BoxError, DispatchError},
    message::Message,
};

// ============================================================================
// Flow Constraints & Traits (from `flow`)
// ============================================================================
pub use crate::{
    core::response::IntoHookOutcome,
    flow::{
        handler::{Handler, HandlerResult},
        hook::{DynHook, Hook, HookResult},
        listener::Listener,
        pipeline::Pipeline,
    },
};
// pub use crate::flow::pipeline::Pipeline;

// Zero-Copy support (GAT-based borrowed processing)
/// Utilities for working with borrowed data in hooks and handlers.
pub mod borrowed {
    pub use crate::flow::borrowed::{BorrowedChain, BorrowedListener, RawMessage};
}

// ============================================================================
// Orchestrator Engine (from `orchestrator`)
// ============================================================================
pub use crate::orchestrator::traits::{Dispatcher, HookProvider};

// Static Dispatch (HList)
pub use crate::orchestrator::r#static::{
    HCons, HListLen, HNil, HookChain, StaticChainBuilder, StaticDispatcher,
};

// Static Fanout
pub use crate::orchestrator::static_fanout::{FanoutChain, StaticFanoutDispatcher};

// ============================================================================
// Dynamic Dispatch & Routing (Source/Registry/Router)
// ============================================================================
// Note: These paths might be broken temporarily until we fix the underlying modules structure
// in the `orchestrator` move phase. For now, pointing to where they currently reside or moved.

// Compatibility Alias
pub type SimpleDynamicDispatcher<P, S> = crate::orchestrator::DynamicDispatcher<P, S>;

// DynDispatcher is now a trait generated by `trait-variant` in `orchestrator::traits`.
// We re-export it from there.
pub use crate::orchestrator::traits::DynDispatcher;

// Delivery strategies for dispatching events to hooks.
pub mod delivery {
    pub use crate::orchestrator::delivery::{DeliveryStrategy, SequentialDelivery};
}

// Dynamic Dispatch
/// Dynamic dispatch support, including Registry and dynamic Hook types.
pub mod dynamic {
    // pub use crate::orchestrator::dynamic::*; // Orchestrator dynamic module is mostly empty/internal now
    pub use crate::orchestrator::{
        DynamicDispatcher, EnabledHandle, RegistrationMeta, Registry, RegistryBuilder,
        dynamic::{DynRouter, DynRouterError, DynamicHook, MutableRouter},
    };
}

// Routing Traits (from `flow`)
// pub use crate::flow::routing::Router; // [TODO] Once trait extracted

// Routing Implementations
/// Routing implementations and traits.
pub mod routing {
    #[cfg(feature = "matchit")]
    pub use crate::std::routing::matchit::MatchitRouter;
    #[cfg(feature = "phf")]
    pub use crate::std::routing::phf::PhfRouter;
    pub use crate::std::routing::{
        hashmap::{HashMapRouter, HashMapRouterBuilder},
        trie_router::TrieRouter,
    };

    // Traits
    pub use crate::flow::routing::{RouteResult, Router, RouterBuilder};
}

pub use crate::std::hooks::routing::RoutingHook;

// ============================================================================
// Standard Library (from `std`)
// ============================================================================
// Listeners
pub use crate::std::listeners::{
    filter::FilterListener, map::MapListener, optional_map::OptionalMapListener,
};
// Hooks
pub use crate::std::hooks::{
    logging::LoggingHook,
    timeout::{TimeoutError, TimeoutExecutor, TimeoutHook},
    tracing::{Traceable, TracingHook},
};
// pub use crate::std::hooks::routing::RoutingHook; // Duplicate export if moved

// ============================================================================
// External Integrations
// ============================================================================
#[cfg(feature = "inventory")]
pub use inventory;

#[cfg(feature = "macros")]
pub use risten_macros::{dispatch, event, main};

pub(crate) mod internal_prelude {

}
